import argparse
from analysis import *
from blazegraph_setup import *
from utils import *
from retrievers import *
from instantiators import *

logger = logging.getLogger(__name__)


def setup_blazegraph(config):
    """
        Create namespaces and upload N-Quads data to Blazegraph for full workflow.

        :param config: Dictionary containing 'endpoints', 'namespaces', and 'data' mappings.
        """

    resources = [
        "height_control_plan_geom",
        "landed_housing_areas_geom",
        "planning_boundary_geom",
        "central_area_geom",
        "conservation_areas_geom",
        "monuments_geom",
        "street_block_plan_geom",
        "urban_design_guideline_geom",
        "urban_design_areas_geom"
    ]

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get('endpoints', 'out_endpoint')
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'

    # regulation endpoint
    create_namespace(input_endpoint, config.get("namespaces", "regulations"))
    upload_nquads(regulation_endpoint, config.get("data", "ontozoning"))

    # scenario endpoint
    if config.getboolean('scenario', 'scenario'):
        create_namespace(input_endpoint, config.get("scenario", "scenario_namespace"))

    # geometry endpoint
    for key in resources:
        ns_name = config.get("namespaces", key)
        geom_file = config.get("data", key)

        create_namespace(input_endpoint, ns_name)
        upload_nquads(f'{input_endpoint}/{ns_name}/sparql', geom_file)
        upload_nquads(regulation_endpoint, geom_file)

    # plot endpoint
    create_namespace(input_endpoint, config.get("namespaces", "plots"))
    upload_nquads(plots_endpoint,  config.get("data", 'plots'))

    logger.info('Blazegraph for full workflow set up.')


def setup_reproducibility_blazegraph(config):
    """
    Create namespaces and upload N-Quads data for 3D land use planning paper reproducibility.

    :param config: Dictionary containing 'endpoints', 'namespaces', and 'data' mappings.
    """

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get('endpoints', 'out_endpoint')
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'
    out_dir = config.get("paths", "out_dir")

    resources = [
        "height_control_plan_geom",
        "landed_housing_areas_geom",
        "planning_boundary_geom",
        "central_area_geom",
        "conservation_areas_geom",
        "monuments_geom",
        "street_block_plan_geom",
        "urban_design_guideline_geom",
        "urban_design_areas_geom"
    ]

    # upload ontozoning data.
    create_namespace(input_endpoint, config.get("namespaces", "regulations"))
    upload_nquads(regulation_endpoint, config.get("data", "ontozoning"))

    # upload regulation geometries
    for key in resources:
        upload_nquads(regulation_endpoint, config.get("data", key))

    # upload n-quads generated by the full workflow.
    for filename in os.listdir(out_dir):
        if filename.endswith(".nq"):
            file_path = os.path.join(out_dir, filename)
            upload_nquads(regulation_endpoint, file_path)

    # upload scenario n-quad data
    if config.getboolean('scenario', 'scenario'):
        create_namespace(input_endpoint, config.get("scenario", "scenario_namespace"))
        scenario_endpoint = config.get('endpoints', 'scenario_endpoint')
        scenario_dir = config.get('paths', 'scenario_dir')

        for filename in os.listdir(scenario_dir):
            if filename.endswith(".nq"):
                file_path = os.path.join(scenario_dir, filename)
                upload_nquads(scenario_endpoint, file_path)

    # upload plot data
    create_namespace(input_endpoint, config.get("namespaces", "plots"))
    upload_nquads(plots_endpoint, config.get("data", "plots"))

    logger.info('Blazegraph for reproducibility workflow set up.')


def instantiate_area_regulations(config):
    """
    Instantiate various regulation contents based on the provided configuration.

    :param config: ConfigParser object containing the configuration settings for endpoints and file paths.
    """

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get("endpoints", "out_endpoint")

    out_dir = config.get("paths", "out_dir")

    height_control_endpoint = f'{input_endpoint}/{config.get("namespaces", "height_control_plan_geom")}/sparql'
    conservation_endpoint = f'{input_endpoint}/{config.get("namespaces", "conservation_areas_geom")}/sparql'
    central_area_endpoint = f'{input_endpoint}/{config.get("namespaces", "central_area_geom")}/sparql'
    planning_boundaries_endpoint = f'{input_endpoint}/{config.get("namespaces", "planning_boundary_geom")}/sparql'
    monuments_endpoint = f'{input_endpoint}/{config.get("namespaces", "monuments_geom")}/sparql'
    landed_housing_areas_endpoint = f'{input_endpoint}/{config.get("namespaces", "landed_housing_areas_geom")}/sparql'
    street_block_plans_endpoint = f'{input_endpoint}/{config.get("namespaces", "street_block_plan_geom")}/sparql'
    urban_design_areas_endpoint = f'{input_endpoint}/{config.get("namespaces", "urban_design_areas_geom")}/sparql'
    urban_design_guidelines_endpoint = f'{input_endpoint}/{config.get("namespaces", "urban_design_guideline_geom")}/sparql'
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'

    instantiate_height_control(height_control_endpoint, out_dir, regulation_endpoint)
    instantiate_conservation_areas(conservation_endpoint, out_dir, regulation_endpoint)
    instantiate_central_area(central_area_endpoint, out_dir, regulation_endpoint)
    instantiate_planning_boundaries(planning_boundaries_endpoint, out_dir, regulation_endpoint)
    instantiate_monuments(monuments_endpoint, out_dir, regulation_endpoint)
    instantiate_landed_housing_areas(landed_housing_areas_endpoint, out_dir, regulation_endpoint)
    instantiate_street_block_plan(street_block_plans_endpoint, out_dir, regulation_endpoint)
    instantiate_urban_design_areas(urban_design_areas_endpoint, out_dir, regulation_endpoint)

    # Retrieve additional data required for guidelines and control plans
    urban_design_areas_df = get_urban_design_areas(regulation_endpoint)

    instantiate_urban_design_guidelines(urban_design_guidelines_endpoint,
                                        urban_design_areas_df,
                                        out_dir,
                                        regulation_endpoint)

    instantiate_area_regulation_overlaps(plots_endpoint, central_area_endpoint, urban_design_areas_endpoint,
                                         conservation_endpoint, monuments_endpoint,planning_boundaries_endpoint,
                                         height_control_endpoint, landed_housing_areas_endpoint,
                                         street_block_plans_endpoint, urban_design_guidelines_endpoint, out_dir,
                                         regulation_endpoint)

    logger.info('Area regulation instantiation complete.')


def enrich_plot_data(config):
    """
    Enriches plot data by processing plots and generating property triples.

    :param config: ConfigParser object containing the configuration settings for endpoints, paths, etc.
    """

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get("endpoints", "out_endpoint")
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'

    out_dir = config.get("paths", "out_dir")
    road_network_dir = config.get("data", "road_network")

    plots = get_plots(plots_endpoint)
    logger.info(f'{len(plots)} plots retrieved from the KG.')

    road_network = gpd.read_file(road_network_dir).to_crs(3857)
    road_network = road_network[['RD_NAME', 'RD_TYP_CD', 'LVL_OF_RD', 'UNIQUE_ID', 'geometry']].copy()
    logger.info(f'{len(road_network)} road network edges retrieved.')

    instantiate_plot_property_triples(plots, road_network, out_dir, regulation_endpoint)
    logger.info('n-quads for plot properties instantiated.')


def instantiate_type_regulations(config):
    """
    Instantiates type-based regulations and links them to plots.

    :param config: ConfigParser object containing the configuration settings for endpoints and file paths.
    """

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get("endpoints", "out_endpoint")
    out_dir = config.get("paths", "out_dir")
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'

    lha = list(get_landed_housing_areas(regulation_endpoint)['reg'])
    pb = get_planning_boundaries(regulation_endpoint)
    control_plans = pd.read_excel(config.get("data", "control_development_excel"))

    instantiate_development_control_plans(control_plans, lha, pb, out_dir, regulation_endpoint)

    plots = get_plots(plots_endpoint)
    plots = plots.drop(columns=['zone'])

    road_list = ['Expressway', 'Semi Expressway', 'Major Arterials/Minor Arterials']
    logger.info(f'{len(plots)} plots retrieved from the KG.')

    type_regs = get_type_regulations(regulation_endpoint)
    logger.info(f'{len(type_regs)} type-based regulations retrieved from the KG.')

    plots = get_plot_properties(plots, regulation_endpoint)
    logger.info('Plot df was enriched with additional plot data.')

    plots = get_plot_neighbour_types(plots, regulation_endpoint)
    logger.info('Plot df was enriched with neighbour type data.')

    plots = get_plot_allowed_programmes(plots, regulation_endpoint)
    logger.info('Plot df was enriched with allowed programmes by area-based regulations.')

    plots = find_allowed_residential_types(plots, road_list)
    logger.info('Plot df was enriched with allowed residential programme types.')

    type_regs_links = link_type_regulations_to_plots(type_regs, plots, road_list)
    logger.info('Type-based regulations linked to plots.')

    instantiate_type_regulation_overlaps(type_regs_links, out_dir, regulation_endpoint)
    logger.info('Triples for type-based regulation links to plots instantiated ot the KG.')


def estimate_allowable_gfas(config):
    """
    Estimates allowable GFA for each plot based on various regulations.

    :param config: ConfigParser object containing the configuration settings for endpoints, paths, etc.
    """

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get("endpoints", "out_endpoint")
    out_dir = config.get("paths", "out_dir")
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'
    gfa_endpoint = config.get("endpoints", "out_endpoint")

    road_list = ['Expressway', 'Semi Expressway', 'Major Arterials/Minor Arterials']

    dcp = get_development_control_plans(regulation_endpoint)
    sbp = get_street_block_plans(regulation_endpoint)
    udg = get_urban_design_guidelines(regulation_endpoint)
    lha = get_landed_housing_areas(regulation_endpoint)
    road_cats = get_road_categories(regulation_endpoint)
    reg_links = get_regulation_links(regulation_endpoint)
    hcp = get_height_control_plans(regulation_endpoint)

    if config.getboolean("scenario", "scenario"):
        out_dir = config.get("paths", "scenario_dir")
        gfa_endpoint = config.get("endpoints", "scenario_endpoint")
        hcp['storeys'] += 1
        hcp['abs_height'] += 4
        logger.info('Scenario parameters set.')
    else:
        logger.info('Base scenario parameters set.')

    plots = get_plots(plots_endpoint)
    plots = process_plots(plots)
    plots = plots.drop(columns=['zone'])

    plots = get_plot_properties(plots, regulation_endpoint)
    logger.info('Plot df was enriched with additional plot data.')

    plots = get_neighbours(plots, regulation_endpoint)
    logger.info('Plot df was enriched with neighbour ids.')

    plots = get_plot_neighbour_types(plots, regulation_endpoint)
    logger.info('Plot df was enriched with neighbour type data.')

    plots = get_plot_allowed_programmes(plots, regulation_endpoint)
    logger.info('Plot df was enriched with allowed programmes by area-based regulations.')

    plots = find_allowed_residential_types(plots, road_list)
    logger.info('Plot df was enriched with allowed residential programme types.')

    plots = assign_gpr(plots, lha, sbp, reg_links)
    logger.info("Relevant plot GPRs set or updated.")

    plots = set_partywall_plots(plots, reg_links, sbp, udg)
    logger.info("Partywall plots set.")

    road_plots = plots.loc[plots['zone'] == 'Road', ['plots', 'geometry', 'road_type']]

    non_gfa_plots = get_unclear_plots(plots, reg_links, hcp, udg)
    gfa_plots = plots[(~plots['plots'].isin(non_gfa_plots))].copy()
    gfa_plots, edges = get_plot_edges(gfa_plots)
    logger.info("Edges dataframe retrieved.")

    # TODO: instead of sbp_plots should be whole gfa_plots df. To be fixed.
    sbp_plots = classify_street_block_plan_plots(gfa_plots, plots, reg_links, road_plots)
    logger.info("Street Block Plan plot neighbors classified.")

    gfa_plots = classify_plot_edges(gfa_plots.copy(), sbp_plots, plots, edges)
    gfa_plots = set_road_buffer_edges(edges, road_plots, gfa_plots)
    gfa_plots = set_partywall_edges(edges, plots, gfa_plots)
    udg_edges = get_udg_edge_setbacks(udg, reg_links, edges)

    # Here you can define the scope of gfa calculation:
    # gfa_plots = gfa_plots.sample(n=1000,  random_state=1)

    res_zones = {
        'Residential',
        'CommercialAndResidential',
        'ResidentialOrInstitution',
        'ResidentialWithCommercialAtFirstStorey'
    }

    gfa_plots = set_plot_edge_setbacks(gfa_plots, reg_links, dcp, sbp, road_cats, udg_edges, res_zones)
    gfa_plots = get_buildable_footprints(gfa_plots.copy())
    gfa_plots = get_buildable_storeys(gfa_plots.copy(), udg, hcp, dcp, lha, sbp, reg_links, res_zones)

    gfa_plots = compute_plot_gfa(gfa_plots.copy(), reg_links, sbp, dcp, res_zones)
    logger.info("GFA values estimated.")

    instantiate_allowed_gfa(gfa_plots, out_dir, gfa_endpoint)
    logger.info("GFA values instantiated.")


def perform_overview_analysis(config):
    """
    Performs an overview analysis by retrieving plots and regulations and prints a summary of regulation overview.

    :param config: A dictionary containing configuration parameters.
    """

    input_endpoint = config.get("endpoints", "in_endpoint")
    regulation_endpoint = config.get("endpoints", "out_endpoint")
    plots_endpoint = f'{input_endpoint}/{config.get("namespaces", "plots")}/sparql'
    out_dir = config.get("paths", "analysis_dir")

    plots = get_plots(plots_endpoint)
    plots = plots.drop(columns=['zone'])
    plots = get_plot_properties(plots, regulation_endpoint)
    logger.info('Plot df was enriched with additional plot data.')

    reg_links = get_regulation_links(regulation_endpoint)
    logger.info('Plots retrieved from the KG.')

    hcp = get_height_control_plans(regulation_endpoint)
    udg = get_urban_design_guidelines(regulation_endpoint)
    non_gfa_plots = get_unclear_plots(plots, reg_links, hcp, udg)

    regs = ['HeightControlPlan',
            'UrbanDesignGuideline',
            'ConservationArea',
            'LandedHousingArea',
            'Monument',
            'DevelopmentControlPlan',
            'StreetBlockPlan',
            'PlanningBoundary',
            'CentralArea']

    get_regulation_overview_df(regulation_endpoint, regs, plots, out_dir=out_dir)

    get_regulation_instance_overview_df(regulation_endpoint, plots, out_dir=out_dir)

    plot_iop(plots, reg_links, out_dir=out_dir)

    plot_gfa_deltas(regulation_endpoint, plots, non_gfa_plots, out_dir=out_dir)

    get_gfa_overview(regulation_endpoint, plots, non_gfa_plots, out_dir=out_dir)

    # if scenario present,
    if config.getboolean('scenario', 'scenario'):
        gfa_endpoint = config.get("endpoints", "scenario_endpoint")
        plot_scenario_difference(regulation_endpoint, gfa_endpoint, plots, reg_links, out_dir=out_dir)


def main():
    config_file = "config.ini"
    config = load_config(config_file)

    # Setup argument parser
    parser = argparse.ArgumentParser(description="Manage GFA model processes.")
    subparsers = parser.add_subparsers(dest="command", help="Sub-command help")

    # Sub-command: setup blazegraph
    parser_setup_blazegraph = subparsers.add_parser("setup-blazegraph",
                                                    help="setup blazegraph for the full workflow")
    parser_setup_blazegraph.set_defaults(func=lambda: setup_blazegraph(config))

    # Sub-command: setup reproducibility graph
    parser_setup_blazegraph = subparsers.add_parser("setup-reproducibility-blazegraph",
                                                    help="setup reproducibility blazegraph for the 3D landuse paper")
    parser_setup_blazegraph.set_defaults(func=lambda: setup_reproducibility_blazegraph(config))

    # Sub-command: instantiate-area-regulations
    parser_area_regulations = subparsers.add_parser("instantiate-area-regulations",
                                                    help="Instantiate area regulations")
    parser_area_regulations.set_defaults(func=lambda: instantiate_area_regulations(config))

    # Sub-command: instantiate-plot-properties
    parser_plot_data = subparsers.add_parser("enrich-plot-data",
                                             help="Enrich plot data with additional properties")
    parser_plot_data.set_defaults(func=lambda: enrich_plot_data(config))

    # Sub-command: instantiate-type-regulations
    parser_type_regulations = subparsers.add_parser("instantiate-type-regulations",
                                                    help="Instantiate type regulations")
    parser_type_regulations.set_defaults(func=lambda: instantiate_type_regulations(config))

    # Sub-command: estimate-allowable-gfas
    parser_gfas = subparsers.add_parser("estimate-allowable-gfas",
                                        help="Estimate allowable GFAs")
    parser_gfas.set_defaults(func=lambda: estimate_allowable_gfas(config))

    # Sub-command: analyze regulatory KG
    parser_analysis = subparsers.add_parser("perform-regulatory-analysis",
                                            help="Perform regulatory data overview analysis")
    parser_analysis.set_defaults(func=lambda: perform_overview_analysis(config))

    # Parse arguments and execute the appropriate function
    args = parser.parse_args()
    if args.command:
        args.func()
    else:
        parser.print_help()


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()


