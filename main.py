import argparse
from analysis import *
from blazegraph_setup import *
from utils import *
from retrievers import *
from instantiators import *

logger = logging.getLogger(__name__)


def setup_blazegraph(config):
    """
        Create namespaces and upload N-Quads data to Blazegraph for full workflow.

        :param config: Dictionary containing 'endpoints', 'namespaces', and 'data' mappings.
        """

    resources = [
        "height_control_plan_geom",
        "landed_housing_areas_geom",
        "planning_boundary_geom",
        "central_area_geom",
        "conservation_areas_geom",
        "monuments_geom",
        "street_block_plan_geom",
        "urban_design_guideline_geom",
        "urban_design_areas_geom"
    ]

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_endpoint = f'{in_endpoint}/{config.get("namespaces", "regulations")}/sparql'
    plots_endpoint = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    create_namespace(in_endpoint, config.get("namespaces", "regulations"))
    upload_nquads(out_endpoint, config.get("data", "ontozoning"))

    for key in resources:
        ns_name = config.get("namespaces", key)
        geom_file = config.get("data", key)

        create_namespace(in_endpoint, ns_name)
        upload_nquads(f'{in_endpoint}/{ns_name}/sparql', geom_file)
        upload_nquads(out_endpoint, geom_file)

    create_namespace(in_endpoint, config.get("namespaces", "plots"))
    upload_nquads(plots_endpoint,  config.get("data", 'plots'))

    logger.info('Blazegraph for full workflow set up.')


def setup_reproducibility_blazegraph(config):
    """
    Create namespaces and upload N-Quads data for 3D land use planning paper reproducibility.

    :param config: Dictionary containing 'endpoints', 'namespaces', and 'data' mappings.
    """

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_dir = config.get("paths", "out_dir")
    out_endpoint = config.get('endpoints', 'out_endpoint')
    plots_endpoint = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    create_namespace(in_endpoint, config.get("namespaces", "plots"))
    create_namespace(in_endpoint, config.get("namespaces", "regulations"))

    upload_nquads(plots_endpoint, config.get("data", "plots"))
    upload_nquads(out_endpoint, config.get("data", "ontozoning"))

    resources = [
        "height_control_plan_geom",
        "landed_housing_areas_geom",
        "planning_boundary_geom",
        "central_area_geom",
        "conservation_areas_geom",
        "monuments_geom",
        "street_block_plan_geom",
        "urban_design_guideline_geom",
        "urban_design_areas_geom"
    ]

    for key in resources:
        upload_nquads(out_endpoint, config.get("data", key))

    # upload n-quads generated by the full workflow.
    for filename in os.listdir(out_dir):
        if filename.endswith(".nq"):
            file_path = os.path.join(out_dir, filename)
            upload_nquads(out_endpoint, file_path)

    logger.info('Blazegraph for reproducibility workflow set up.')


def instantiate_area_regulations(config):
    """
    Instantiate various regulation contents based on the provided configuration.

    :param config: ConfigParser object containing the configuration settings for endpoints and file paths.
    """

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_endpoint = config.get("endpoints", "out_endpoint")

    out_dir = config.get("paths", "out_dir")

    height_control_endpoint = f'{in_endpoint}/{config.get("namespaces", "height_control_plan_geom")}/sparql'
    conservation_endpoint = f'{in_endpoint}/{config.get("namespaces", "conservation_areas_geom")}/sparql'
    central_area_endpoint = f'{in_endpoint}/{config.get("namespaces", "central_area_geom")}/sparql'
    planning_boundaries_endpoint = f'{in_endpoint}/{config.get("namespaces", "planning_boundary_geom")}/sparql'
    monuments_endpoint = f'{in_endpoint}/{config.get("namespaces", "monuments_geom")}/sparql'
    landed_housing_areas_endpoint = f'{in_endpoint}/{config.get("namespaces", "landed_housing_areas_geom")}/sparql'
    street_block_plans_endpoint = f'{in_endpoint}/{config.get("namespaces", "street_block_plan_geom")}/sparql'
    urban_design_areas_endpoint = f'{in_endpoint}/{config.get("namespaces", "urban_design_areas_geom")}/sparql'
    urban_design_guidelines_endpoint = f'{in_endpoint}/{config.get("namespaces", "urban_design_guideline_geom")}/sparql'
    plots_endpoint = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    instantiate_height_control(height_control_endpoint, out_dir, out_endpoint)
    instantiate_conservation_areas(conservation_endpoint, out_dir, out_endpoint)
    instantiate_central_area(central_area_endpoint, out_dir, out_endpoint)
    instantiate_planning_boundaries(planning_boundaries_endpoint, out_dir, out_endpoint)
    instantiate_monuments(monuments_endpoint, out_dir, out_endpoint)
    instantiate_landed_housing_areas(landed_housing_areas_endpoint, out_dir, out_endpoint)
    instantiate_street_block_plan(street_block_plans_endpoint, out_dir, out_endpoint)
    instantiate_urban_design_areas(urban_design_areas_endpoint, out_dir, out_endpoint)

    # Retrieve additional data required for guidelines and control plans
    urban_design_areas_df = get_urban_design_areas(out_endpoint)
    instantiate_urban_design_guidelines(urban_design_guidelines_endpoint, urban_design_areas_df, out_dir, out_endpoint)

    instantiate_area_regulation_overlaps(plots_endpoint, central_area_endpoint, urban_design_areas_endpoint,
                                         conservation_endpoint, monuments_endpoint,planning_boundaries_endpoint,
                                         height_control_endpoint, landed_housing_areas_endpoint,
                                         street_block_plans_endpoint, urban_design_guidelines_endpoint, out_dir,
                                         out_endpoint)
    logger.info('Area regulation instantiation complete.')


def enrich_plot_data(config):
    """
    Enriches plot data by processing plots and generating property triples.

    :param config: ConfigParser object containing the configuration settings for endpoints, paths, etc.
    """

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_endpoint = config.get("endpoints", "out_endpoint")
    out_dir = config.get("paths", "out_dir")
    road_network_path = config.get("data", "road_network")
    plots_namespace = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    plots = get_plots(plots_namespace)
    logger.info(f'{len(plots)} plots retrieved from the KG.')

    road_network = gpd.read_file(road_network_path).to_crs(3857)
    road_network = road_network[['RD_NAME', 'RD_TYP_CD', 'LVL_OF_RD', 'UNIQUE_ID', 'geometry']].copy()
    logger.info(f'{len(road_network)} road network edges retrieved.')

    instantiate_plot_property_triples(plots, road_network, out_dir, out_endpoint)
    logger.info('n-quads for plot properties instantiated.')


def instantiate_type_regulations(config):
    """
    Instantiates type-based regulations and links them to plots.

    :param config: ConfigParser object containing the configuration settings for endpoints and file paths.
    """

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_endpoint = config.get("endpoints", "out_endpoint")
    out_dir = config.get("paths", "out_dir")
    plots_namespace = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    lha = list(get_landed_housing_areas(out_endpoint)['reg'])
    pb = get_planning_boundaries(out_endpoint)
    control_plans = pd.read_excel(config.get("data", "control_development_excel"))

    instantiate_development_control_plans(control_plans, lha, pb, out_dir, out_endpoint)

    plots = get_plots(plots_namespace)
    plots = plots.drop(columns=['zone'])

    road_list = ['Expressway', 'Semi Expressway', 'Major Arterials/Minor Arterials']
    logger.info(f'{len(plots)} plots retrieved from the KG.')

    type_regs = get_type_regulations(out_endpoint)
    logger.info(f'{len(type_regs)} type-based regulations retrieved from the KG.')

    plots = get_plot_properties(plots, out_endpoint)
    logger.info('plot df was enriched with additional plot data.')

    plots = get_plot_neighbour_types(plots, out_endpoint)
    logger.info('plot df was enriched with neighbour type data.')

    plots = get_plot_allowed_programmes(plots, out_endpoint)
    logger.info('plot df was enriched with allowed programmes by area-based regulations.')

    plots = find_allowed_residential_types(plots, road_list)
    logger.info('plot df was enriched with allowed residential programme types.')

    type_regs_links = link_type_regulations_to_plots(type_regs, plots, road_list)
    logger.info('type-based regulations linked to plots.')

    instantiate_type_regulation_overlaps(type_regs_links, out_dir, out_endpoint)
    logger.info('triples for type-based regulation links to plots instantiated ot the KG.')


def estimate_allowable_gfas(config):
    """
    Estimates allowable GFA for each plot based on various regulations.

    :param config: ConfigParser object containing the configuration settings for endpoints, paths, etc.
    """

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_endpoint = config.get("endpoints", "out_endpoint")
    out_dir = config.get("paths", "out_dir")
    plots_namespace = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    road_list = ['Expressway', 'Semi Expressway', 'Major Arterials/Minor Arterials']

    dcp = get_development_control_plans(out_endpoint)
    sbp = get_street_block_plans(out_endpoint)
    hcp = get_height_control_plans(out_endpoint)
    udg = get_urban_design_guidelines(out_endpoint)
    lha = get_landed_housing_areas(out_endpoint)
    road_cats = get_road_categories(out_endpoint)
    reg_links = get_regulation_links(out_endpoint)

    plots = get_plots(plots_namespace)
    plots = process_plots(plots)
    plots = plots.drop(columns=['zone'])

    plots = get_plot_properties(plots, out_endpoint)
    logger.info('Plot df was enriched with additional plot data.')

    plots = get_neighbours(plots, out_endpoint)
    logger.info('Plot df was enriched with neighbour ids.')

    plots = get_plot_neighbour_types(plots, out_endpoint)
    logger.info('Plot df was enriched with neighbour type data.')

    plots = get_plot_allowed_programmes(plots, out_endpoint)
    logger.info('Plot df was enriched with allowed programmes by area-based regulations.')

    plots = find_allowed_residential_types(plots, road_list)
    logger.info('Plot df was enriched with allowed residential programme types.')

    plots = assign_gpr(plots, lha, sbp, reg_links)
    logger.info("Relevant plot GPRs set or updated.")

    plots = set_partywall_plots(plots, reg_links, sbp, udg)
    logger.info("Partywall plots set.")

    road_plots = plots.loc[plots['zone'] == 'Road', ['plots', 'geometry', 'road_type']]

    non_gfa_plots = get_unclear_plots(plots, reg_links, hcp, udg)
    gfa_plots = plots[(~plots['plots'].isin(non_gfa_plots))].copy()
    gfa_plots, edges = get_plot_edges(gfa_plots)
    logger.info("Edges dataframe retrieved.")

    # TODO: instead of sbp_plots should be whole gfa_plots df. To be fixed.
    sbp_plots = classify_street_block_plan_plots(gfa_plots, plots, reg_links, road_plots)
    logger.info("Street Block Plan plot neighbors classified.")

    gfa_plots = classify_plot_edges(gfa_plots.copy(), sbp_plots, plots, edges)
    gfa_plots = set_road_buffer_edges(edges, road_plots, gfa_plots)
    gfa_plots = set_partywall_edges(edges, plots, gfa_plots)
    udg_edges = get_udg_edge_setbacks(udg, reg_links, edges)

    '<----------------------------Test Start------------------------------>'

    # gfa_plots = gfa_plots.sample(n=1000,  random_state=1) // Here you can define the scope of gfa calculation:

    res_zones = {
        'Residential',
        'CommercialAndResidential',
        'ResidentialOrInstitution',
        'ResidentialWithCommercialAtFirstStorey'
    }

    gfa_plots = set_plot_edge_setbacks(gfa_plots, reg_links, dcp, sbp, road_cats, udg_edges, res_zones)
    gfa_plots = get_buildable_footprints(gfa_plots)
    gfa_plots = get_buildable_storeys(gfa_plots.copy(), udg, hcp, dcp, lha, sbp, reg_links, res_zones)

    gfa_plots = compute_plot_gfa(gfa_plots.copy(), reg_links, sbp, dcp, res_zones)
    logger.info("GFA values estimated.")

    instantiate_allowed_gfa(gfa_plots, out_dir, out_endpoint)
    logger.info("GFA values instantiated.")


def perform_overview_analysis(config):
    """
    Performs an overview analysis by retrieving plots and regulations and prints a summary of regulation overview.

    :param config: A dictionary containing configuration parameters.
    """

    in_endpoint = config.get("endpoints", "in_endpoint")
    out_endpoint = config.get("endpoints", "out_endpoint")
    out_dir = config.get("paths", "analysis_dir")
    plots_namespace = f'{in_endpoint}/{config.get("namespaces", "plots")}/sparql'

    plots = get_plots(plots_namespace)
    reg_links = get_regulation_links(out_endpoint)
    logger.info('Plots retrieved from the KG.')

    hcp = get_height_control_plans(out_endpoint)
    udg = get_urban_design_guidelines(out_endpoint)
    non_gfa_plots = get_unclear_plots(plots, reg_links, hcp, udg)

    regs = ['HeightControlPlan',
            'UrbanDesignGuideline',
            'ConservationArea',
            'LandedHousingArea',
            'Monument',
            'DevelopmentControlPlan',
            'StreetBlockPlan',
            'PlanningBoundary',
            'CentralArea']

    get_regulation_overview_df(out_endpoint, regs, plots, out_dir=out_dir)
    logger.info('Regulation summary saved.')

    get_regulation_instance_overview_df(out_endpoint, plots, out_dir=out_dir)
    logger.info('Regulation instance overview saved.')

    plot_iop(plots, reg_links, out_dir=out_dir)
    logger.info('Intensitiy of plannedness saved.')

    plot_gfa_deltas(out_endpoint, plots, non_gfa_plots, out_dir=out_dir)
    logger.info('GFA deltas saved.')

    get_gfa_overview(out_endpoint, plots, non_gfa_plots, out_dir=out_dir)
    logger.info('GFA overview saved.')


def main():
    config_file = "config.ini"
    config = load_config(config_file)

    # Setup argument parser
    parser = argparse.ArgumentParser(description="Manage GFA model processes.")
    subparsers = parser.add_subparsers(dest="command", help="Sub-command help")

    # Sub-command: setup blazegraph
    parser_setup_blazegraph = subparsers.add_parser("setup-blazegraph",
                                                    help="setup blazegraph for the full workflow")
    parser_setup_blazegraph.set_defaults(func=lambda: setup_blazegraph(config))

    # Sub-command: setup reproducibility graph
    parser_setup_blazegraph = subparsers.add_parser("setup-reproducibility-blazegraph",
                                                    help="setup reproducibility blazegraph for the 3D landuse paper")
    parser_setup_blazegraph.set_defaults(func=lambda: setup_reproducibility_blazegraph(config))

    # Sub-command: instantiate-area-regulations
    parser_area_regulations = subparsers.add_parser("instantiate-area-regulations",
                                                    help="Instantiate area regulations")
    parser_area_regulations.set_defaults(func=lambda: instantiate_area_regulations(config))

    # Sub-command: instantiate-plot-properties
    parser_plot_data = subparsers.add_parser("enrich-plot-data",
                                             help="Enrich plot data with additional properties")
    parser_plot_data.set_defaults(func=lambda: enrich_plot_data(config))

    # Sub-command: instantiate-type-regulations
    parser_type_regulations = subparsers.add_parser("instantiate-type-regulations",
                                                    help="Instantiate type regulations")
    parser_type_regulations.set_defaults(func=lambda: instantiate_type_regulations(config))

    # Sub-command: estimate-allowable-gfas
    parser_gfas = subparsers.add_parser("estimate-allowable-gfas",
                                        help="Estimate allowable GFAs")
    parser_gfas.set_defaults(func=lambda: estimate_allowable_gfas(config))

    # Sub-command: analyze regulatory KG
    parser_analysis = subparsers.add_parser("perform-regulatory-analysis",
                                            help="Perform regulatory data overview analysis")
    parser_analysis.set_defaults(func=lambda: perform_overview_analysis(config))

    # Parse arguments and execute the appropriate function
    args = parser.parse_args()
    if args.command:
        args.func()
    else:
        parser.print_help()


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()


